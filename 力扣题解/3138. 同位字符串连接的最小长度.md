---
created: 2024-12-20T01:19
tag: 力扣题解
title: 3138. 同位字符串连接的最小长度
updated: 2025-02-17T22:03
---
给你一个字符串 `s` ，它由某个字符串 `t` 和若干 `t`  的 **同位字符串** 连接而成。

请你返回字符串 `t` 的 **最小** 可能长度。

**同位字符串** 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。

**示例 1：**

**输入：**s = "abba"

**输出：**2

**解释：**

一个可能的字符串 `t` 为 `"ba"` 。

**示例 2：**

**输入：**s = "cdef"

**输出：**4

**解释：**

一个可能的字符串 `t` 为 `"cdef"` ，注意 `t` 可能等于 `s` 。

**提示：**

- `1 <= s.length <= 105`
- `s` 只包含小写英文字母。
### 1. 整体思路

这个问题的关键在于找到能够重复组成给定字符串`s`的最小单元字符串`t`的长度。我们通过尝试不同长度的子串（从长度 1 开始，逐步增加，直到字符串长度本身），检查该长度的子串能否通过重复若干次来构成整个字符串`s`。如果能找到这样合适的子串长度，那么这个长度就是字符串`t`的最小可能长度。

### 2. 代码详细分析

- **函数定义和参数**：

```
def gcd_str(s):
```

定义了一个名为`gcd_str`的函数，它接受一个字符串`s`作为参数，目的是找出组成`s`的最小重复单元字符串的长度。

- **遍历可能的长度**：

```
n = len(s)
for length in range(1, n + 1):
    if n % length == 0:
```

首先获取输入字符串`s`的长度`n`，然后使用`for`循环遍历从 1 到`n`的所有可能长度（因为最小单元字符串长度可能是 1 到整个字符串长度之间的任何值，只要能整除字符串总长度就行），通过判断`n`能否被当前长度`length`整除来确定是否进一步检查该长度是否符合要求（只有能整除总长度的长度才有希望成为最小重复单元的长度）。

- **检查子串是否符合要求**：

```
t = s[:length]
flag = True
for i in range(length, n, length):
    sub_s = s[i:i + length]
    sub_t_c = Counter(sub_s)
    t_c = Counter(t)
    if sub_t_c!= t_c:
        flag = False
        break
```
  
对于每个能整除总长度的长度`length`，先取出字符串`s`开头长度为`length`的子串`t`，然后通过一个内层`for`循环，以步长为`length`去依次取出后面同长度的子串`sub_s`。利用 Python 的`Counter`类来统计子串`sub_s`和`t`中每个字符出现的次数，比较它们是否相等。如果有任何一处不相等，说明当前长度的子串不能作为重复单元，将标志`flag`设为`False`并跳出内层循环。

- **返回结果**：
  
```
if flag:
    return length
return n
```

如果经过内层循环检查后，标志`flag`仍为`True`，说明找到了合适的最小重复单元长度，直接返回这个长度`length`；如果遍历完所有可能长度都没有找到合适的，那就返回整个字符串的长度`n`，意味着整个字符串本身就是那个不能再拆分的最小单元。

这个算法的时间复杂度是，其中`n`是输入字符串的长度，因为在最糟糕的情况下，我们需要对每个可能的子串长度（从 1 到`n`）去遍历整个字符串来检查子串是否符合条件。空间复杂度取决于`Counter`对象占用的空间，大致是，其中`m`是字符集的大小（本题中为小写英文字母个数 26），因为`Counter`统计的是不同字符出现的频次，最多会记录 26 种不同字符的频次情况。