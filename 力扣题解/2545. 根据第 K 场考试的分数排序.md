---
created: 2024-12-21T03:54
tag: 力扣题解
title: 2545. 根据第 K 场考试的分数排序
updated: 2024-12-30T23:33
---
班里有 `m` 位学生，共计划组织 `n` 场考试。给你一个下标从 **0** 开始、大小为 `m x n` 的整数矩阵 `score` ，其中每一行对应一位学生，而 `score[i][j]` 表示第 `i` 位学生在第 `j` 场考试取得的分数。矩阵 `score` 包含的整数 **互不相同** 。

另给你一个整数 `k` 。请你按第 `k` 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。

返回排序后的矩阵。

**示例 1：**

![](https://assets.leetcode.com/uploads/2022/11/30/example1.png)

**输入：**score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
**输出：**[[7,5,11,2],[10,6,9,1],[4,8,3,15]]
**解释：**在上图中，S 表示学生，E 表示考试。
- 下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。
- 下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。
- 下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。

**示例 2：**

![](https://assets.leetcode.com/uploads/2022/11/30/example2.png)

**输入：**score = [[3,4],[5,6]], k = 0
**输出：**[[5,6],[3,4]]
**解释：**在上图中，S 表示学生，E 表示考试。
- 下标为 1 的学生在第 0 场考试取得的分数为 5 ，这是考试的最高分，所以 TA 需要排在第一。
- 下标为 0 的学生在第 0 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第二。

**提示：**

- `m == score.length`
- `n == score[i].length`
- `1 <= m, n <= 250`
- `1 <= score[i][j] <= 105`
- `score` 由 **不同** 的整数组成
- `0 <= k < n`
以下是使用Python语言解决上述问题的代码实现：

```python
def sortTheStudents(score, k):
    return sorted(score, key=lambda x: -x[k])

```

你可以使用以下方式调用这个函数：
```python
score = [[10, 6, 9, 1], [7, 5, 11, 2], [4, 8, 3, 15]]
k = 2
print(sortTheStudents(score, k))
```

以下是对上述代码的解释：

### 1. 整体思路
题目要求按照第`k`场考试的分数对学生（矩阵中的行）进行从高到低的排序。Python中的内置函数`sorted`提供了很方便的排序功能，我们只需要指定合适的排序关键字（`key`参数），让其按照每个子列表（代表每个学生的成绩列表）中索引为`k`的元素（即第`k`场考试的成绩）来进行排序，并且通过取负号来实现从高到低的降序排序效果。

### 2. 代码详细分析
- **函数定义和参数**：
```python
def sortTheStudents(score, k):
```
定义了名为`sortTheStudents`的函数，它接受两个参数，`score`是表示学生成绩的二维矩阵（列表的列表形式），`k`表示按照哪一场考试的成绩来进行排序的索引值（从0开始计数）。

- **使用`sorted`函数排序**：
```python
return sorted(score, key=lambda x: -x[k])
```
这里调用了Python的内置函数`sorted`对`score`进行排序。`sorted`函数会返回一个新的已排好序的列表，不会改变原列表。其中`key`参数指定了排序的依据，这里使用了一个匿名函数（`lambda`表达式）`lambda x: -x[k]`，对于传入的参数`x`（这里`x`代表`score`中的每一行，也就是每个学生的成绩列表），返回`-x[k]`，意味着按照每个学生成绩列表中索引为`k`的成绩取负后的值来进行排序。取负的操作使得原本数值大的成绩在排序时会排在前面，从而实现从高到低的排序效果。

该算法的时间复杂度取决于Python内置`sorted`函数的实现，一般对于长度为`m`的可迭代对象（这里是学生的数量）进行排序，时间复杂度接近 $O(m \log m)$，空间复杂度大致为 $O(m)$，因为需要额外的空间来存储排序后的结果（新的已排序列表）。
