---
created: 2025-01-15T03:10
updated: 2025-01-15T03:13
---
### 操作系统功能与数据结构
1. **操作系统功能**：涵盖进程管理、存储管理、设备管理、文件管理和作业管理等。各功能模块协同工作，负责协调和管理计算机系统中的不同资源。
2. **资源管理数据结构**：
    - 进程控制块（PCB）：用于管理进程信息，包含进程标识符、状态、优先级等。
    - 文件控制块（FCB）：管理文件相关信息，如文件名、文件大小、文件权限等。
    - 页表：在存储管理中，记录页面与物理块的映射关系 ，用于实现逻辑地址到物理地址的转换。

### 进程调度
1. **先来先服务（FCFS）**：
    - **调度规则**：按照进程到达的先后顺序进行调度，调度顺序等同于进程到达顺序。
    - **周转时间计算**：周转时间 = 完成时间 - 到达时间。
    - **例题**：有三个进程P1、P2、P3，到达时间分别是0、1、3，运行时间分别为5、3、2。
        - P1周转时间 = 5 - 0 = 5
        - P2周转时间 = (5 + 3)- 1 = 7
        - P3周转时间 = (5 + 3 + 2)- 3 = 7
        - 平均周转时间=(5 + 7 + 7)/3 = 19/3 
2. **短作业优先（SJF）**：
    - **调度规则**：优先调度预计运行时间最短的进程。
    - **周转时间计算**：同FCFS，周转时间 = 完成时间 - 到达时间 ，需先确定每个进程的预计运行时间来安排调度顺序。
    - **例题**：有四个进程P1、P2、P3、P4，到达时间都为0，运行时间分别为7、5、3、1。
        - 调度顺序为P4、P3、P2、P1。
        - P4周转时间 = 1 - 0 = 1
        - P3周转时间 = (1 + 3)- 0 = 4
        - P2周转时间 = (1 + 3 + 5)- 0 = 9
        - P1周转时间 = (1 + 3 + 5 + 7)- 0 = 16
        - 平均周转时间=(1 + 4 + 9 + 16)/4 = 30/4 = 7.5 

### 银行家算法
1. **目的**：避免死锁，通过检查系统资源分配情况，判断是否能安全分配资源给进程。
2. **关键数据结构**：
    - 可利用资源向量Available：表示系统中各类可利用资源的数量。
    - 最大需求矩阵Max：每个进程对各类资源的最大需求。
    - 分配矩阵Allocation：每个进程当前已分配到的各类资源数量。
    - 需求矩阵Need：每个进程还需要的各类资源数量（Need = Max - Allocation）。
3. **算法步骤**：检查每个进程的需求是否都能被满足（即Need[i] <= Available），若能满足则系统处于安全状态，可分配资源。
4. **例题**：系统中有三类资源R1、R2、R3，数量分别为9、3、6。有五个进程P1 - P5，它们的最大需求矩阵Max、分配矩阵Allocation如下：
|进程|Max(R1,R2,R3)|Allocation(R1,R2,R3)|
|----|--------------|---------------------|
|P1|(3,2,2)|(1,0,0)|
|P2|(6,1,3)|(4,1,1)|
|P3|(3,1,4)|(2,1,1)|
|P4|(4,2,2)|(0,0,2)|
|P5|(5,2,3)|(1,1,1)|
    - 解答：
        - 先计算每个进程的需求矩阵Need = Max - Allocation
|进程|Need(R1,R2,R3)|
|----|--------------|
|P1|(2,2,2)|
|P2|(2,0,2)|
|P3|(1,0,3)|
|P4|(4,2,0)|
|P5|(4,1,2)|
        - 计算可利用资源向量Available = 资源总量 - 已分配资源总量=(9 - (1+4+2+0+1),3 - (0+1+1+0+1),6 - (0+1+1+2+1))=(1,0,1)
        - 发现P3的需求(1,0,3)可以满足，先把P3的资源释放，Available变为(1+2,0+1,1+1)=(3,1,2)。
        - 接着P2的需求(2,0,2)可以满足，释放P2资源后，Available变为(3+4,1+1,2+1)=(7,2,3)。
        - 以此类推，最后可以把所有进程的资源需求都满足，所以系统处于安全状态。

### 进程同步 - 生产者 - 消费者问题扩展
1. **信号量定义和初值**：
    - 互斥信号量mutex：用于保证对共享资源（如缓冲区）的互斥访问，初值为1。
    - 资源信号量empty：表示缓冲区中的空闲位置数量，初值为缓冲区大小n。
    - 资源信号量full：表示缓冲区中已有的产品数量，初值为0。

### 分页地址变换计算
1. **基本原理**：逻辑地址分为页号和页内偏移。通过页表找到页号对应的物理块号，再将物理块号与页内偏移组合得到物理地址。
2. **计算步骤**：逻辑地址A，页大小为L，页号 = A / L（整除），页内偏移 = A % L 。根据页号查页表得到物理块号，物理地址 = 物理块号 * L + 页内偏移。
3. **例题**：某系统采用分页存储管理，页大小为4KB，逻辑地址为32位。已知某进程的页表如下（部分）：
|页号|物理块号|
|----|--------|
|0|2|
|1|4|
|2|6|
    - 若逻辑地址为0x00001FFF，求物理地址。
    - 解答：
        - 页大小为4KB = 2^12B，所以页内偏移占12位，页号占32 - 12 = 20位。
        - 0x00001FFF转换为二进制是0000 0000 0000 0000 0001 1111 1111 1111，页号为0000 0000 0000 0000 0001（二进制）= 1（十进制），页内偏移为1111 1111 1111（二进制）。
        - 根据页表，页号1对应的物理块号是4。
        - 物理地址 = 物理块号 * 页大小 + 页内偏移 = 4 * 4KB+ (4095)（十进制）= 4 * 2^12 + 4095 = 16384 + 4095 = 20479（十进制），转换为十六进制为0x4FFF。

### 页面置换算法
1. **缺页率计算**：缺页率 = 缺页次数 / 总访问页面数。
2. **最佳置换算法（OPT）**：选择未来最长时间内不会被访问的页面进行置换。需要预先知道进程未来的页面访问序列才能准确实现。
3. **先进先出置换算法（FIFO）**：选择最先进入内存的页面进行置换。通过维护一个页面进入内存的顺序队列来实现。
4. **最近最少使用算法（LRU）**：选择最近一段时间内最久未使用的页面进行置换。可通过记录页面的访问时间戳等方式实现。
5. **预调页策略和请求调页策略**：
    - 请求调页：当进程访问的页面不在内存时，才将该页面调入内存。
    - 预调页：根据程序的局部性原理，预测进程即将访问的页面并提前调入内存。
6. **例题**：假设系统为某进程分配了3个物理页面，进程访问页面的顺序为7、0、1、2、0、3、0、4。
    - **FIFO算法**：
        - 初始物理页面为空，第一次访问7，缺页，放入物理页面；访问0，缺页，放入；访问1，缺页，放入。此时物理页面为7、0、1。
        - 访问2，缺页，将最早进入的7置换出去，放入2，物理页面为2、0、1。
        - 访问0，不缺页；访问3，缺页，将0置换出去，放入3，物理页面为2、3、1。
        - 访问0，缺页，将1置换出去，放入0，物理页面为2、3、0。
        - 访问4，缺页，将2置换出去，放入4，物理页面为4、3、0。
        - 缺页次数为6，总访问页面数为8，缺页率 = 6/8 = 0.75。
    - **LRU算法**：
        - 初始物理页面为空，第一次访问7，缺页，放入物理页面；访问0，缺页，放入；访问1，缺页，放入。此时物理页面为7、0、1。
        - 访问2，缺页，将最久未使用的7置换出去，放入2，物理页面为2、0、1。
        - 访问0，不缺页，调整顺序为0、2、1（0最近使用）。
        - 访问3，缺页，将最久未使用的2置换出去，放入3，物理页面为0、3、1。
        - 访问0，不缺页，调整顺序为0、3、1。
        - 访问4，缺页，将最久未使用的3置换出去，放入4，物理页面为0、4、1。
        - 缺页次数为5，总访问页面数为8，缺页率 = 5/8 = 0.625。

### 磁盘调度
1. **先来先服务（FCFS）**：
    - **调度规则**：按磁盘请求到达的先后顺序进行调度，实际访问顺序即请求到达顺序。
    - **距离计算**：计算相邻请求的磁道距离累加。
    - **例题**：磁盘有200个磁道（0 - 199），磁头当前在100磁道。有磁盘请求序列为55、58、39、18、90、160、150、38、184。
        - 移动顺序为100 - 55 - 58 - 39 - 18 - 90 - 160 - 150 - 38 - 184。
        - 距离 = |100 - 55|+|55 - 58|+|58 - 39|+|39 - 18|+|18 - 90|+|90 - 160|+|160 - 150|+|150 - 38|+|38 - 184|
        - = 45 + 3 + 19 + 21 + 72 + 70 + 10 + 112 + 146 = 498。
2. **最短寻道时间优先（SSTF）**：
    - **调度规则**：优先调度距离当前磁头位置最近的磁道请求，每次都从当前磁头位置出发，选择距离最近的请求进行服务。
    - **例题**：磁盘有200个磁道（0 - 199），磁头当前在100磁道。有磁盘请求序列为55、58、39、18、90、160、150、38、184。
        - 首先距离100最近的是90，移动顺序为100 - 90 - 58 - 55 - 39 - 38 - 18 - 150 - 160 - 184。
        - 距离 = |100 - 90|+|90 - 58|+|58 - 55|+|55 - 39|+|39 - 38|+|38 - 18|+|18 - 150|+|150 - 160|+|160 - 184|
        - = 10 + 32 + 3 + 16 + 1 + 20 + 132 + 10 + 24 = 248。
3. **电梯算法（SCAN）**：
    - **调度规则**：磁头在一个方向上移动，访问完所有要访问的磁道后，再反向移动。先确定磁头移动方向，然后按照该方向依次访问磁道请求。
    - **例题**：磁盘有200个磁道（0 - 199），磁头当前在100磁道。有磁盘请求序列为55、58、39、18、90、160、150、38、184。假设向磁道号增大方向扫描。
        - 移动顺序为100 - 150 - 160 - 184 - 199（到头后返回）- 90 - 58 - 55 - 39 - 38 - 18。
        - 距离 = |100 - 150|+|150 - 160|+|160 - 184|+|184 - 199|+|199 - 90|+|90 - 58|+|58 - 55|+|55 - 39|+|39 - 38|+|38 - 18|
        - = 50 + 10 + 24 + 15 + 109 + 32 + 3 + 16 + 1 + 20 = 280。 