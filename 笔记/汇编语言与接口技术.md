---
created: 2025-03-05T19:48
updated: 2025-03-06T17:31
---
## 冯・诺依曼计算机体系结构

由==运算器、控制器、存储器、输入设备和输出设备==组成。运算器承担算术与逻辑运算，如在财务数据统计时进行加、减、乘、除运算；控制器则像乐队指挥，协调各部件协同工作，在计算机启动加载操作系统过程中起关键调度作用；存储器用于存储程序和数据，分内存（如 8GB、16GB 运行内存，速度快但断电数据丢失）和外存（如 1TB 硬盘，容量大用于长期存储）；输入设备将外部信息，如键盘输入文字、摄像头采集图像，转换为二进制数据输入计算机；输出设备把计算机处理结果，以显示器显示画面、打印机输出纸质文档等可感知形式呈现。

## 系统总线与内部总线

系统总线连接计算机主要部件，传输数据、地址和控制信号，像数据总线负责数据传输，32 位数据总线一次能传输 4 字节数据，在 CPU 与内存数据交互时起关键作用；地址总线确定数据存储地址，决定计算机可寻址内存空间大小，16 位地址总线可寻址 64KB 内存；控制总线协调操作，如 CPU 向内存发送读写控制信号。常见的 ISA、PCI、AGP 总线都属于系统总线。内部总线用于部件内部各功能单元间信息传递，例如在 ARM 芯片内部，AMBA 总线连接 CPU、内存、外设等模块；在集成电路设计中，Wishbone 总线实现芯片内不同功能模块通信，二者不存在包含关系。

## 计算机发展时代

### 电子管计算机时代（1946 - 1957 年）

采用电子管作为核心元件，ENIAC 作为代表机型，体积庞大，占地 170 平方米，重达 30 吨，耗电量大，可靠性差，运算速度慢，每秒仅能进行几千次到几万次基本运算。使用机器语言和汇编语言编程，主要应用于科学计算和军事领域，如军事弹道计算。

### 晶体管计算机时代（1958 - 1964 年）

晶体管替代电子管，计算机体积大幅缩小，功耗降低，可靠性提升，运算速度达到每秒几十万到几百万次。出现高级程序设计语言，如 FORTRAN 用于科学计算，COBOL 用于商业数据处理。代表机型 IBM 7090、7094，在气象数据处理、企业财务核算等方面发挥重要作用，应用领域从单纯科学计算扩展到数据处理和事务管理。

### 集成电路计算机时代（1965 - 1970 年）

采用集成电路，多个晶体管等元件集成在芯片上，计算机体积进一步缩小，性能显著提升，运算速度达每秒几百万到几千万次。操作系统逐渐成熟，如 IBM 的 OS/360。计算机向标准化、系列化、通用化发展，便于大规模生产和维护，应用领域拓宽至工业控制、通信等，例如工厂自动化生产线控制。代表机型 IBM System/360 系列，具有良好兼容性和扩展性，不同配置可满足不同用户需求。

### 大规模和超大规模集成电路计算机时代（1971 年至今）

集成电路集成度不断提高，微处理器出现开启计算机微型化进程。英特尔 8086、8088 等微处理器推动个人计算机发展，苹果 Macintosh 系列以其独特设计和用户体验，IBM PC 系列以其通用性和扩展性，促使个人计算机迅速普及。计算机网络飞速发展，从早期局域网到如今的互联网，改变人们生活和工作方式，如在线办公、电子商务兴起。软件技术创新不断，各类操作系统（Windows、Mac OS、Linux）、数据库管理系统（MySQL、Oracle）、应用软件（办公软件、游戏软件）层出不穷。

## 微型计算机特点

采用大规模和超大规模集成电路技术，具备体积小（如笔记本电脑便于携带）、重量轻（普通笔记本 1.5 - 3 千克）、功耗低（笔记本功率几十瓦）、可靠性高（平均无故障时间长）、灵活性高（可按需选择 CPU、内存等配置，连接多种外部设备）、价格便宜（从入门级到高端产品覆盖不同价格区间）、运算速度快（高端 CPU 主频 3GHz 以上，多核心多线程）、兼容性强（硬件遵循接口标准可相互兼容，软件适配多种操作系统）等特点，能满足个人办公、家庭娱乐、工业控制等不同应用需求。

## 计算机硬件核心部件

中央处理器（CPU），由==运算器、控制器和寄存器==组成。运算器执行算术与逻辑运算，在图形渲染时对像素数据进行复杂运算；控制器指挥各部件，按照指令要求协调工作；寄存器暂存数据和指令，加速数据处理，例如在 CPU 执行指令过程中，数据先存于寄存器便于快速运算。其主频、核心数、缓存大小等性能参数决定计算机整体性能，如高主频可提升运算速度，多核心增强多任务处理能力。

## I/O 设备

即输入输出设备。输入设备如键盘通过按键输入文字、鼠标移动控制光标位置、扫描仪将纸质文档数字化、摄像头采集视频图像、麦克风录入声音，将外部信息转换为计算机能识别的二进制数据；输出设备如显示器显示文字图像视频、打印机输出纸质文档、音箱播放声音、绘图仪绘制工程图纸，将计算机处理结果以可感知形式输出。

## 存储器

### RAM（随机存取存储器）

==具有随机存取、易失性、高速读写特点==。分为 SRAM（静态随机存取存储器，速度快，用于 CPU 高速缓存，减少 CPU 等待数据时间，但集成度低、成本高，容量相对小）和 DRAM（动态随机存取存储器，集成度高、成本低，用于计算机主内存，提供较大内存空间，但速度相对 SRAM 慢，需定期刷新以保持数据）。

### ROM（只读存储器）

==只读、非易失性==。制造时固化数据，工作时只能读出。有掩膜 ROM（生产时固化数据，无法更改，用于早期计算机 BIOS）、PROM（可编程只读存储器，用户可一次性写入数据，如特定设备初始设置）、EPROM（可擦除可编程只读存储器，通过紫外线照射擦除数据，可多次编程，如早期单片机程序烧写）、EEPROM（电可擦除可编程只读存储器，用电信号擦除和编程，方便灵活，如主板 BIOS 设置信息存储）等类型。

## 计算机存储设备

==固态硬盘属于外存储设备==，用闪存芯片存储数据，相比传统机械硬盘，具有读写速度快（顺序读取可达每秒数百兆甚至数千兆字节）、抗震性强（无机械部件，受震动不易损坏）、低功耗（节省电量，延长移动设备续航）、噪音小（无机械转动噪音）等优势，广泛应用于计算机、移动设备等。

## 微处理器

世界上==第一个可编程的微处理器是英特尔 4004==，1971 年发布，集成 2300 个晶体管，能处理 4 位数据，有 45 条指令，时钟频率 108KHz，运算速度每秒 5 万条指令。它标志微处理器时代到来，使计算机向小型化、智能化发展，为后续微处理器不断升级迭代奠定基础。

## 操作系统

==Windows 属于系统软件==，能管理计算机硬件和软件资源。在硬件管理方面，合理分配 CPU 时间、管理内存空间、提供设备驱动（如显卡驱动、打印机驱动），让硬件设备正常工作；在软件管理方面，提供用户界面（图形化桌面、窗口、菜单）方便用户操作，构建程序运行环境（加载应用程序、分配系统资源），支持各种软件运行，如办公软件、游戏软件等。



# 8086微处理器体系结构详解笔记


## **一、内存地址系统**
### 1. 物理地址计算原理
- **公式**：物理地址 = 段基址 × 16 + 偏移地址  
  - **段基址**：16位寄存器值（如DS/CS/SS/ES），左移4位（乘以16）生成20位基址  
  - **偏移地址**：16位有效地址（EA），由寻址方式计算  
- **示例**：  
  ```assembly
  段基址 = 1234H → 左移4位 → 12340H  
  偏移地址 = 5678H → 物理地址 = 12340H + 5678H = 179B8H
  ```

### 2. 分段管理机制
- **段寄存器**：

| 寄存器 | 名称       | 用途                          |
|--------|------------|-------------------------------|
| CS     | 代码段     | 指令存放区基址                |
| DS     | 数据段     | 全局数据区基址                |
| SS     | 堆栈段     | 堆栈区基址                    |
| ES     | 附加段     | 辅助数据区基址（如串操作目标）|
- **段基址提取**：  
  数据段起始地址 `12345H` → 段基址 = `12345H >> 4` = `1234H`


## **二、寄存器组详解**
### 1. 通用寄存器（16位）
| 寄存器 | 功能分类   | 低8位  | 高8位  | 典型用途                  |
|--------|------------|--------|--------|---------------------------|
| AX     | 累加器     | AL     | AH     | 算术运算、I/O操作         |
| BX     | 基址寄存器 | BL     | BH     | 内存间接寻址基地址        |
| CX     | 计数器     | CL     | CH     | 循环次数、串操作长度      |
| DX     | 数据寄存器 | DL     | DH     | 32位运算高半部分、I/O端口 |
| SP     | 堆栈指针   | -      | -      | 指向栈顶（SS:SP）         |
| BP     | 基址指针   | -      | -      | 访问堆栈局部变量          |
| SI     | 源变址     | -      | -      | 串操作源地址              |
| DI     | 目的变址   | -      | -      | 串操作目的地址            |

### 2. 控制寄存器
- **IP（指令指针）**：  
  - 始终指向当前代码段中下一条指令的偏移地址  
  - 物理地址 = CS × 16 + IP  
- **FLAGS（标志寄存器）**：  

|   标志位    |    名称         |   置位条件                     | 作用                     | 
|--------|--------------|------------------------------|--------------------------|
| CF     | 进位标志     | 最高位产生进位/借位          | 无符号数溢出判断        |
| PF     | 奇偶标志     | 结果中1的个数为偶数          | 数据校验                |
| AF     | 辅助进位标志 | 低4位向高4位进位/借位       | BCD运算调整             |
| ZF     | 零标志       | 结果为0                      | 条件判断                |
| SF     | 符号标志     | 结果最高位为1（负数）        | 有符号数符号指示        |
| OF     | 溢出标志     | 有符号数运算超出范围         | 有符号数溢出判断        |
| DF     | 方向标志     | CLD/STD指令显式设置         | 串操作方向控制（递增/递减）|

## **三、有效地址（EA）计算**
### 1. 寻址方式分类
| 方式      | 格式示例                | EA计算方法             | 用途场景      |
| ------- | ------------------- | ------------------ | --------- |
| 立即寻址    | MOV AX, 1234H       | 直接使用立即数            | 常数赋值      |
| 直接寻址    | MOV AX, [1234H]     | EA = 1234H         | 固定地址访问    |
| 寄存器寻址   | MOV AX, BX          | EA = BX寄存器值        | 快速数据访问    |
| 寄存器间接寻址 | MOV AX, [BX]        | EA = BX寄存器值        | 数组元素访问    |
| 寄存器相对寻址 | MOV AX, [BX+10H]    | EA = BX + 10H      | 带偏移量的数组访问 |
| 基址变址寻址  | MOV AX, [BX+SI]     | EA = BX + SI       | 二维数组访问    |
| 相对基址变址  | MOV AX, [BX+SI+10H] | EA = BX + SI + 10H | 复杂数据结构访问  |

### 2. 典型应用示例
```assembly
; 假设BX=1000H, SI=2000H
MOV AX, [BX+SI+3000H]  ; EA = 1000H + 2000H + 3000H = 6000H
```


## **四、十六进制运算技巧**
### 1. 快速加法
- **规则**：逐位相加，超过F则进位  
  ```assembly
  3A (58) + 2B (43) = 65 (101)  
  计算过程：A(10)+B(11)=21 → 5余1，3+2+1=6 → 结果65H
  ```

### 2. 补码减法
- **步骤**：  
  1. 取减数的按位取反（如3C → C3）  
  2. 加1得到补码（C3 + 1 = C4）  
  3. 被减数 + 补码，舍去最高位进位  
  ```assembly
  8A (138) - 3C (60) = 5E (94)  
  计算过程：8A + C4 = 15E → 舍去进位得5E
  ```

### 3. 十进制转换
- **除16取余法**：  
  ```assembly
  21 ÷ 16 = 1 余5 → 结果15H  
  255 ÷ 16 = 15 余15 → 结果FFH
  ```


## **五、典型编程应用**
### 1. 数据段访问示例
```assembly
DATA_SEG SEGMENT
    ARRAY DB 10H, 20H, 30H  ; 数据段定义
DATA_SEG ENDS

CODE_SEG SEGMENT
    ASSUME CS:CODE_SEG, DS:DATA_SEG
START:
    MOV AX, DATA_SEG        ; 加载段基址到AX
    MOV DS, AX              ; 设置DS寄存器
    MOV BX, OFFSET ARRAY    ; BX = ARRAY偏移地址
    MOV AL, [BX]            ; AL = 10H
    HLT
CODE_SEG ENDS
END START
```

### 2. 堆栈操作示例
```assembly
PUSH AX    ; SP = SP - 2，AX值压入SS:SP
POP BX     ; BX = SS:SP值，SP = SP + 2
```


## **六、常见问题解析**
1. **段基址与物理地址的关系**  
   - 段基址是物理地址的高16位部分（右移4位后的值）  
   - 物理地址范围：段基址×16 ~ 段基址×16 + FFFFH

2. **FLAGS标志位的应用**  
   ```assembly
   CMP AX, BX    ; 比较AX与BX
   JZ  EQUAL     ; ZF=1时跳转
   JG  GREATER   ; SF=OF且ZF=0时跳转（有符号数大于）
   ```

3. **有效地址与偏移地址的区别**  
   - 有效地址（EA）是计算出的偏移地址  
   - 偏移地址是EA经过段基址转换后的最终地址分量


**总结**：8086体系通过分段管理实现1MB寻址空间，寄存器组分工明确，有效地址计算灵活支持多种数据结构，FLAGS标志位控制程序流程，十六进制运算能力是底层编程的基础。掌握这些核心概念是深入理解汇编语言和计算机体系结构的关键。
